# Scene Events & Narrative Generation

## The Core Concept

Stories unfold in **scenes** (or chapters/acts—naming TBD). During an active scene, all participant activity—chat, player actions, votes, challenges—flows through a unified **event stream**. When the scene concludes, this event log is sent to OpenAI to generate polished narrative prose.

**Think of it like this:**
- **During the scene:** Players and spectators create a messy, collaborative event log (OOC chat, declared actions, votes on challenges)
- **After the scene:** AI transforms that log into a finished story chapter
- **The permanent artifact:** Polished narrative prose that spectators pay Ink to unlock

---

## Event Types

Everything that happens in a scene is an **event** in a timeline. Event types include:

- **OOC Chat**: Players talking out of character ("lol my character would totally do that")
- **Player Action**: Character action declarations ("Kira investigates the ancient runes")
- **Director Action**: System/GM-injected events ("A shadowy figure emerges")
- **Vote**: Spectator votes on challenges or character performances
- **Challenge**: Spectator-submitted complications to throw at players
- **Milestone**: Scene transitions, act breaks, meta-events

All events share common properties (who, when, which scene) but have type-specific payloads.

---

## The Flow

### During Active Scene

1. Participants connect via WebSocket to a scene
2. They create events (chat, actions, votes)
3. Events are written to the database with timestamps
4. Events broadcast in real-time to all scene participants
5. Everyone sees the live, messy, collaborative creation process

**Key point:** No AI generation happens here. Just raw event capture and broadcast.

### When Scene Closes

1. Scene ends (timer? vote? consensus? TBD)
2. Batch job fetches all events for that scene (ordered by timestamp)
3. Events are grouped/filtered by type and sent to OpenAI
4. OpenAI prompt: "Here's OOC chat (player intent), player actions (what happened), votes (complications). Generate narrative prose with IC dialog and scene descriptions."
5. Store the AI-generated narrative as a finished chapter
6. Mark scene as complete

**Key point:** Narrative generation is a batch process, not real-time.

---

## Who Sees What

### Players (Participants)

**During scene:**
- See all events in real-time (chat, actions, votes, everything)
- Can create events (OOC chat, player actions)
- Raw, collaborative, messy experience

**After scene:**
- Get the finished narrative for free (they participated!)
- Can optionally review the raw event log alongside the narrative

### Spectators (Audience)

**During scene:**
- Limited or no visibility (TBD—maybe they only see vote opportunities, maybe nothing)
- Can participate via votes/challenges if allowed

**After scene:**
- Prompted to unlock the finished narrative for Ink
- See polished prose, NOT the raw event log
- This is their primary value: reading finished stories

---

## Technical Model

### SceneEvent (Real-Time)

- Unified entity for all event types
- Stored with scene ID + timestamp for ordered queries
- Discriminated by event type (chat vs action vs vote)
- Broadcast via DDB streams to WebSocket connections

### ChapterNarrative (Finished Product)

- Generated by OpenAI after scene closes
- Contains polished prose
- References source event IDs (audit trail)
- Has unlock cost for spectators

### Infrastructure

**One WebSocket per participant:**
- Handles all event types (don't need separate sockets for chat vs game commands)
- Events are routed by type within the same connection
- Simplifies client management, reduces AWS costs

**Same broadcast pattern for all events:**
- Write to DDB → Stream triggers → Broadcast to scene participants
- Whether it's chat, actions, or votes, same infrastructure

---

## Why This Design

**Unified event model:**
- Chat and game actions aren't separate concerns—they're both part of the story timeline
- Easier to query "everything that happened in this scene" for AI prompting
- Single broadcast infrastructure for all event types

**Batch narrative generation:**
- Real-time AI generation is expensive and slow
- Batch processing lets us craft better prompts (full context)
- Creates a clear boundary between "live collaborative play" and "finished story artifact"

**Clear participant/spectator split:**
- Players experience the raw creation process
- Spectators consume the polished result
- Different value propositions, different Ink economics

---

## Open Questions

1. **Naming:** Scene vs Chapter vs Act? (What's the hierarchy?)
2. **Scene closure trigger:** Timer, vote, event count, manual?
3. **Spectator real-time access:** Can they see anything during active scene? Or pure suspense until it's done?
4. **Event retention:** Keep raw events after narrative generation? (Yes for audit, but forever?)
5. **Narrative re-rolls:** Can players spend Ink to regenerate narrative if they don't like the output?

---

## Migration Path

Current implementation has "chat" with messages in rooms. To evolve:

1. Rename `ChatMessage` → `SceneEvent`
2. Rename `roomId` → `sceneId`
3. Add `eventType` field (start with just `"ooc_chat"`)
4. Add event routing in WebSocket handler
5. Chat continues to work exactly the same
6. Later: add new event types (player actions, votes) using the same infrastructure

This way we're not building "chat with game bolted on," we're building "a scene event system where chat is the first event type."

---

## Summary

- Everything that happens in a scene is an **event** (chat, actions, votes, etc.)
- Events flow through **one WebSocket**, broadcast in real-time to participants
- When the scene ends, the event log is sent to **OpenAI** to generate polished narrative
- **Players** see raw events live, get narrative free after
- **Spectators** pay Ink to unlock finished narratives
- This scales from simple chat today to complex multi-event storytelling tomorrow